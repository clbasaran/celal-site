<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="index, follow">
    
    <title>Firebase ile iOS UygulamalarÄ±nda Real-time Veri â€” Celal BaÅŸaran</title>
    <meta name="description" content="Firebase Firestore kullanarak iOS uygulamalarÄ±nÄ±zda gerÃ§ek zamanlÄ± veri senkronizasyonu nasÄ±l yapÄ±lÄ±r? Combine framework ile entegrasyon Ã¶rnekleri.">
    <meta name="keywords" content="Firebase, iOS Development, Real-time Data, Firestore, SwiftUI, Authentication">
    <meta name="author" content="Celal BaÅŸaran">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://celalbasaran.com/posts/firebase-realtime.html" />
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Firebase ile iOS UygulamalarÄ±nda Real-time Veri">
    <meta property="og:description" content="Firebase Firestore kullanarak iOS uygulamalarÄ±nÄ±zda gerÃ§ek zamanlÄ± veri senkronizasyonu.">
    <meta property="og:image" content="https://celalbasaran.com/cb.png">
    <meta property="og:url" content="https://celalbasaran.com/posts/firebase-realtime.html">
    <meta property="og:type" content="article">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="../cb.png">
    <link rel="apple-touch-icon" href="../cb.png">
    
    <!-- Stylesheet -->
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="blog-post-page">
        <div class="container">
            <!-- Navigation -->
            <nav class="post-nav">
                <a href="../blog.html" class="back-link">â† Blog'a Geri DÃ¶n</a>
            </nav>
            
            <!-- Post Header -->
            <header class="post-header">
                <div class="post-date">8 MayÄ±s 2025</div>
                <h1 class="post-title">Firebase ile iOS UygulamalarÄ±nda Real-time Veri</h1>
                <p class="post-subtitle">Firebase Firestore kullanarak iOS uygulamalarÄ±nÄ±zda gerÃ§ek zamanlÄ± veri senkronizasyonu nasÄ±l yapÄ±lÄ±r? Combine framework ile entegrasyon Ã¶rnekleri.</p>
            </header>
            
            <!-- Post Content -->
            <article class="post-content">
                <h2>ğŸ”¥ Firebase Neden Bu Kadar PopÃ¼ler?</h2>
                <p>Firebase, Google'Ä±n geliÅŸtirdiÄŸi backend-as-a-service (BaaS) platformu olarak, iOS geliÅŸtiricilerin hayatÄ±nÄ± bÃ¼yÃ¼k Ã¶lÃ§Ã¼de kolaylaÅŸtÄ±rÄ±yor. Ã–zellikle real-time uygulamalar geliÅŸtirmek istediÄŸinizde Firebase'in sunduÄŸu avantajlar:</p>
                
                <ul>
                    <li><strong>GerÃ§ek zamanlÄ± veri senkronizasyonu:</strong> Firestore ile veriler anlÄ±k olarak tÃ¼m cihazlarda senkronize olur</li>
                    <li><strong>Otomatik offline cache:</strong> Ä°nternet baÄŸlantÄ±sÄ± olmadÄ±ÄŸÄ±nda bile uygulama Ã§alÄ±ÅŸmaya devam eder</li>
                    <li><strong>Kolay authentication yÃ¶netimi:</strong> Email, Google, Apple ID gibi Ã§oklu giriÅŸ seÃ§enekleri</li>
                    <li><strong>SwiftUI ile tam uyum:</strong> Reactive programming paradigmasÄ± ile mÃ¼kemmel entegrasyon</li>
                </ul>

                <h2>ğŸ“¡ Firestore ile GerÃ§ek ZamanlÄ± Veri</h2>
                <p>Firestore'un en gÃ¼Ã§lÃ¼ Ã¶zelliklerinden biri <code>addSnapshotListener</code> metodudur. Bu metod sayesinde veritabanÄ±ndaki deÄŸiÅŸiklikleri gerÃ§ek zamanlÄ± olarak takip edebilirsiniz:</p>
                
                <pre><code>import FirebaseFirestore

class MessageService: ObservableObject {
    @Published var messages: [Message] = []
    private var db = Firestore.firestore()
    private var listener: ListenerRegistration?
    
    func startListening() {
        listener = db.collection("mesajlar")
            .order(by: "timestamp", descending: false)
            .addSnapshotListener { [weak self] snapshot, error in
                guard let documents = snapshot?.documents else {
                    print("Error fetching documents: \(error?.localizedDescription ?? "Unknown error")")
                    return
                }
                
                self?.messages = documents.compactMap { document in
                    try? document.data(as: Message.self)
                }
            }
    }
    
    func stopListening() {
        listener?.remove()
    }
}</code></pre>
                
                <h2>ğŸ”„ SnapshotListener vs getDocuments</h2>
                <p>Firebase'de veri Ã§ekmenin iki ana yÃ¶ntemi vardÄ±r. Her birinin kendine Ã¶zgÃ¼ kullanÄ±m alanlarÄ± vardÄ±r:</p>
                
                <div style="overflow-x: auto; margin: 1.5rem 0;">
                    <table style="width: 100%; border-collapse: collapse; background: var(--surface-elevated); border-radius: 8px; overflow: hidden;">
                        <thead>
                            <tr style="background: var(--primary); color: white;">
                                <th style="padding: 1rem; text-align: left;">YÃ¶ntem</th>
                                <th style="padding: 1rem; text-align: left;">KullanÄ±m AlanÄ±</th>
                                <th style="padding: 1rem; text-align: left;">Avantajlar</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr style="border-bottom: 1px solid var(--border);">
                                <td style="padding: 1rem; color: var(--text-primary);"><code>getDocuments()</code></td>
                                <td style="padding: 1rem; color: var(--text-secondary);">Tek seferlik veri Ã§ekimi</td>
                                <td style="padding: 1rem; color: var(--text-secondary);">DÃ¼ÅŸÃ¼k maliyet, basit implementasyon</td>
                            </tr>
                            <tr>
                                <td style="padding: 1rem; color: var(--text-primary);"><code>addSnapshotListener</code></td>
                                <td style="padding: 1rem; color: var(--text-secondary);">GerÃ§ek zamanlÄ± veri takibi</td>
                                <td style="padding: 1rem; color: var(--text-secondary);">Otomatik gÃ¼ncellemeler, reactive UI</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h2>ğŸ” Authentication Entegrasyonu</h2>
                <p>Firebase Authentication ile kullanÄ±cÄ± yÃ¶netimi oldukÃ§a basittir. SwiftUI ile entegre bir giriÅŸ sistemi oluÅŸturmak iÃ§in:</p>
                
                <pre><code>import FirebaseAuth

class AuthService: ObservableObject {
    @Published var isSignedIn = false
    @Published var currentUser: User?
    
    init() {
        // Auth state deÄŸiÅŸikliklerini dinle
        Auth.auth().addStateDidChangeListener { [weak self] _, user in
            self?.isSignedIn = user != nil
            self?.currentUser = user
        }
    }
    
    func signIn(withEmail email: String, password: String) async throws {
        let result = try await Auth.auth().signIn(withEmail: email, password: password)
        await MainActor.run {
            self.currentUser = result.user
        }
    }
    
    func signOut() throws {
        try Auth.auth().signOut()
        currentUser = nil
    }
}</code></pre>

                <h2>ğŸŒ Offline DesteÄŸi</h2>
                <p>Firebase'in en gÃ¼Ã§lÃ¼ Ã¶zelliklerinden biri offline destek saÄŸlamasÄ±dÄ±r. UygulamanÄ±z internet baÄŸlantÄ±sÄ± olmadÄ±ÄŸÄ±nda bile Ã§alÄ±ÅŸmaya devam eder:</p>
                
                <pre><code>// AppDelegate veya SceneDelegate iÃ§inde
import FirebaseFirestore

func configureFirestore() {
    let settings = FirestoreSettings()
    settings.isPersistenceEnabled = true
    settings.cacheSizeBytes = FirestoreCacheSizeUnlimited
    
    Firestore.firestore().settings = settings
}

// Offline veri yazma
func addMessageOffline(_ message: Message) {
    db.collection("mesajlar").addDocument(data: [
        "text": message.text,
        "userId": message.userId,
        "timestamp": FieldValue.serverTimestamp()
    ]) { error in
        // Bu iÅŸlem offline bile olsa cache'e yazÄ±lÄ±r
        // Ä°nternet baÄŸlantÄ±sÄ± geldiÄŸinde otomatik sync olur
    }
}</code></pre>

                <h2>ğŸ’¡ GeliÅŸtiriciye Tavsiyeler</h2>
                <p>Firebase ile Ã§alÄ±ÅŸÄ±rken dikkat etmeniz gereken Ã¶nemli noktalar:</p>
                
                <ul>
                    <li><strong>DocumentSnapshot.exists kontrolÃ¼ yap:</strong> Her zaman belgenin var olup olmadÄ±ÄŸÄ±nÄ± kontrol edin</li>
                    <li><strong>Lifecycle iÃ§inde listener'larÄ± iyi yÃ¶net:</strong> <code>onDisappear</code> veya <code>deinit</code> iÃ§inde listener'larÄ± kaldÄ±rÄ±n</li>
                    <li><strong>Security rules konfigÃ¼rasyonlarÄ±nÄ± ihmal etme:</strong> Production'da mutlaka gÃ¼venlik kurallarÄ±nÄ± tanÄ±mlayÄ±n</li>
                    <li><strong>ObservableObject + @Published ile SwiftUI'da baÄŸlam kur:</strong> Reactive programming paradigmasÄ±nÄ± tam olarak kullanÄ±n</li>
                    <li><strong>Pagination kullan:</strong> BÃ¼yÃ¼k veri setleri iÃ§in <code>limit()</code> ve <code>startAfter()</code> metodlarÄ±nÄ± kullanÄ±n</li>
                </ul>

                <h2>ğŸ¯ SwiftUI ile Pratik Ã–rnek</h2>
                <p>Firebase'i SwiftUI ile kullanÄ±rken en iyi pratikleri gÃ¶steren basit bir chat uygulamasÄ± Ã¶rneÄŸi:</p>
                
                <pre><code>struct ChatView: View {
    @StateObject private var messageService = MessageService()
    @State private var newMessageText = ""
    
    var body: some View {
        VStack {
            ScrollView {
                LazyVStack {
                    ForEach(messageService.messages) { message in
                        MessageRow(message: message)
                    }
                }
            }
            
            HStack {
                TextField("Mesaj yazÄ±n...", text: $newMessageText)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                
                Button("GÃ¶nder") {
                    messageService.sendMessage(newMessageText)
                    newMessageText = ""
                }
                .disabled(newMessageText.isEmpty)
            }
            .padding()
        }
        .onAppear {
            messageService.startListening()
        }
        .onDisappear {
            messageService.stopListening()
        }
    }
}</code></pre>

                <h2>ğŸ§¾ SonuÃ§</h2>
                <p>Firebase, backend gerektirmeyen ama anlÄ±k veri saÄŸlayan gÃ¼Ã§lÃ¼ bir altyapÄ± sunar. Bu sistemle iOS uygulamalarÄ±nÄ±z Ã§ok daha interaktif ve modern hale gelir. Ã–zellikle chat uygulamalarÄ±, collaborative tools ve real-time dashboard'lar iÃ§in mÃ¼kemmel bir seÃ§imdir.</p>
                
                <p>Firebase'in sunduÄŸu offline destek, automatic scaling ve gÃ¼venlik Ã¶zellikleri ile birlikte, kÃ¼Ã§Ã¼k prototypelerden bÃ¼yÃ¼k Ã¶lÃ§ekli uygulamalara kadar geniÅŸ bir yelpazede kullanÄ±labilir.</p>
                
                <p>Bir sonraki yazÄ±mda Firebase Cloud Functions ile backend logic'i nasÄ±l yÃ¶netebileceÄŸiniz konusuna deÄŸineceÄŸim. Takipte kalÄ±n! ğŸš€</p>
            </article>
            
            <!-- Post Footer -->
            <footer class="post-footer">
                <div class="author-info">
                    <img src="../cb.png" alt="Celal BaÅŸaran" class="author-avatar">
                    <div class="author-details">
                        <h4>Celal BaÅŸaran</h4>
                        <p>iOS Developer & Firebase Enthusiast</p>
                    </div>
                </div>
                
                <nav class="post-navigation">
                    <a href="../blog.html" class="nav-link">â† TÃ¼m YazÄ±lar</a>
                    <a href="swiftui-modern-ui.html" class="nav-link">Sonraki YazÄ± â†’</a>
                </nav>
            </footer>
        </div>
    </div>
</body>
</html> 